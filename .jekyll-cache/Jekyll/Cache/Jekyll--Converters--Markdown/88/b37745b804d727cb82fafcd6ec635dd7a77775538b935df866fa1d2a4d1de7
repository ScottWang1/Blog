I"Ù<h2 id="the-garbage-collection">The Garbage Collection</h2>

<h2 id="mark-sweep">Mark-sweep</h2>
<p>The first algorithm that we look at is mark-sweep collection. It is a straightforward embodiment of the recursive definition of pointer reachability. Collection operates in two phases. First, the collector traverses the graph of objects, starting from the roots (registers, thread stacks, global variables) through which the program might immediately access objects and then following pointers and marking each object that it finds. Such a traversal is called tracing. In the second, sweeping phase, the collector examines every object in the heap: any unmarked object is deemed to be garbage and its space reclaimed.
Mark-sweep is an indirect collection algorithm. It does not detect garbage per se, but rather identifies all the live objects and then concludes that anything else must be garbage. Note that it needs to recalculate its estimate of the set of live objects at each invocation. Not all garbage collection algorithms behave like this. 
<img src="http://localhost:4000/assets/images/2.1.png" alt="å›¾ç‰‡pic1" />
<img src="http://localhost:4000/assets/images/2.2.png" alt="å›¾ç‰‡pic1" /></p>

<p>Termination of the marking phase is enforced by not adding already marked objects to the work list, so that eventually the list will become empty. At this point, every object reachable from the roots will have been visited and its mark-bit will have been set. Any unmarked object is therefore garbage.
<img src="http://localhost:4000/assets/images/2.3.png" alt="å›¾ç‰‡pic1" />
The sweep phase returns unmarked nodes to the allocator (Algorithm 2.3). Typically,
the collector sweeps the heap linearly, starting from the bottom, freeing unmarked nodes
and resetting the mark-bits of marked nodes in preparation for the next collection cycle.</p>
<h5 id="bitmap-marking">Bitmap marking</h5>
<p>It can be improved by Bitmap marking. With a bitmap, marking will not modify any object, but will only read pointer fields of live objects. Other than loading the type descriptor field, no other part of pointer-free objects will be accessed. Sweeping will not read or write to any live object although it may overwrite fields of garbage objects as part of freeing them (for example to link them into a free-list). Thus bitmap marking is likely to modify fewer words, and to dirty fewer cache lines so less data needs to be written back to memory. Bitmap marking was also motivated by the concern to minimise the amount of paging caused by the collector</p>
<h5 id="lazy-sweeping">Lazy sweeping</h5>
<p>We observe two properties of objects and their mark-bits. First, once an object is garbage, it remains garbage: it can neither be seen nor be resurrected by a mutator. Second, mutators cannot access mark-bits. Thus, the sweeper can be executed in parallel with mutator threads, modifying mark-bits and even overwriting fields of garbage objects to link them into allocator structures. The sweeper (or sweepers) could be executed as separate threads, running concurrently with the mutator threads, but a simple solution is to use lazy sweeping. Lazy sweeping amortises the cost of sweeping by having the allocator perform the sweep. Rather than a separate sweep phase, the responsibility for finding free space is devolved to allocate. At its simplest, allocate advances the sweep pointer until it finds sufficient space in a sequence of unmarked objects. However, it is more practical to sweep a block of several objects at a time.</p>

<p>Lazy sweeping offers a number of benefits. It has good locality: object slots tend to be used soon after they are swept. It reduces the algorithmic complexity of mark-sweep to be proportional to the size of the live data in the heap, the same as semispace copying collection</p>
<h2 id="mark-compact-garbage-collection">Mark-compact garbage collection</h2>
<p>The strategy we consider is in-place compaction of objects into one end of the same region.</p>
<h5 id="two-finger-compaction">Two-finger compaction</h5>
<p>This Agorithm starts with two pointers or â€˜fingersâ€™, free which points to the start of the region and scan which starts at the end of the region. The first pass repeatedly advances the free pointer until it finds a gap (an unmarked object) in the heap, and retreats the scan pointer until it finds a live object. If the free and scan fingers pass each other, the phase is complete. Otherwise, the object at scan is moved into the gap at free, overwriting a field of the old copy (at scan) with a forwarding address, and the process continue.
<img src="http://localhost:4000/assets/images/3.1.png" alt="å›¾ç‰‡pic1" />
The benefits of this algorithm are that it is simple and fast, doing minimal work at each iteration, but the order of objects in the heap that results from this style of compaction is arbitrary, and this tends to harm the mutatorâ€™s locality.</p>
<h5 id="the-lisp-2-algorithm">The Lisp 2 algorithm</h5>
<p>It makes three passes over the heap, each iteration does little work</p>
<h2 id="loading-linking-and-initializing">Loading, Linking, and Initializing</h2>

<h2 id="the-java-virtual-machine-instruction-set">The Java Virtual Machine Instruction Set</h2>

<h2 id="opcode-mnemonics-by-opcode">Opcode Mnemonics by Opcode</h2>

<p><a href="./">back</a></p>
:ET