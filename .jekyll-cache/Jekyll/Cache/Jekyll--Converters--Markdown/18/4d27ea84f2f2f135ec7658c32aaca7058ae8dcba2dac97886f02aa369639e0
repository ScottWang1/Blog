I"Â<h2 id="the-garbage-collection">The Garbage Collection</h2>

<h2 id="mark-sweep">Mark-sweep</h2>
<p>The first algorithm that we look at is mark-sweep collection. It is a straightforward embodiment of the recursive definition of pointer reachability. Collection operates in two phases. First, the collector traverses the graph of objects, starting from the roots (registers, thread stacks, global variables) through which the program might immediately access objects and then following pointers and marking each object that it finds. Such a traversal is called tracing. In the second, sweeping phase, the collector examines every object in the heap: any unmarked object is deemed to be garbage and its space reclaimed.
Mark-sweep is an indirect collection algorithm. It does not detect garbage per se, but rather identifies all the live objects and then concludes that anything else must be garbage. Note that it needs to recalculate its estimate of the set of live objects at each invocation. Not all garbage collection algorithms behave like this. 
<img src="http://localhost:4000/assets/images/2.1.png" alt="å›¾ç‰‡pic1" />
<img src="http://localhost:4000/assets/images/2.2.png" alt="å›¾ç‰‡pic1" /></p>

<p>Termination of the marking phase is enforced by not adding already marked objects to the work list, so that eventually the list will become empty. At this point, every object</p>
<h2 id="the-class-file-format">The â€˜classâ€™ File Format</h2>

<h2 id="loading-linking-and-initializing">Loading, Linking, and Initializing</h2>

<h2 id="the-java-virtual-machine-instruction-set">The Java Virtual Machine Instruction Set</h2>

<h2 id="opcode-mnemonics-by-opcode">Opcode Mnemonics by Opcode</h2>

<p><a href="./">back</a></p>
:ET